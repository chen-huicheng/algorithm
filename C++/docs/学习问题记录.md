# 学习问题记录

+ #### c++ 结构体, 类如何对齐、为什么要进行内存对齐?

>Win32平台下的微软C编译器(cl.exe for 80×86)的**对齐策略：**
>**1)** **结构体变量的首地址能够被其最宽基本类型成员的大小所整除；**
>
>> 备注：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。
>
>**2)** **结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）；**
>
>> *备注:为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。*
>
>**3)** **结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节（trailing padding）。**
>
>> *备注：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。*
>
>
>
>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
>  对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。	
>
>[demo ](../src/c++Primer/memory/Memory.cpp)    [参考 ](https://www.cnblogs.com/kira2will/p/4106111.html)

+ #### c++ 中输出的地址  以及内存中地址的关系？

> 虚拟内存 真实内存
>
> 

+ #### 编译  汇编  的基本命令有哪些，怎么用？

>常用命令 [参考](https://blog.csdn.net/qq_36287943/article/details/106531594)
>
>| 命令     | 解释      | 基本用法 |
>| -------- | --------- | -------- |
>| mov      | 数据传送  | mov      |
>| call     |           |          |
>| add      | add ax,bx |          |
>| sub      | sub ax,bx |          |
>| push     |           |          |
>| pop      |           |          |
>| test  je |           |          |
>
>



+ #### 汇编的基本思想 总体框架  如何理解？

>

+ #### 磁盘 固态 内存条 读取原理  工作原理？

>
>
>[内存工作原理](https://blog.csdn.net/qq_40587575/article/details/79111255)

+ #### 操作系统  内存管理部分？

> 

+ #### `template<int inst> ` 理解  模板的使用 偏特化 等

> 

+ #### 虚函数与虚函数表 虚函数的用法

>

+ 



